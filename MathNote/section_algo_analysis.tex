\section{算法分析}



\fontsize{9}{11}
\selectfont

[主定理的证明，http://blog.csdn.net/u014627430/article/details/53510696]

[Mark Allen Weiss, 数据结构与算法分析，第十章]


\fontsize{10}{11}
\selectfont
\vspace{0.5cm}

\subsection{算法复杂度的数学定义}
\begin{definition}
关于算法的复杂度本文使用如下定义

\begin{enumerate}
\item 如果对于所有足够大的$n$，$T(N)$的上界由$f(N)$的常数倍决定，也就是说，如果存在正常数$c$和$n_0$，使得当$N \ge n_0$时， 都有$T(N) \le cf(N)$，则记为$ T(N) = \bigo(f(N))$。
\item 对于所有足够大的$n$，$T(N)$的下界由$g(N)$的常数倍决定， 也就是说，如果存在正常数$c$和$n_0$，使得当$N \ge n_0$时， 都有$T(N) \ge cg(N)$，则记为$ T(N) = \Om(g(N))$。
\item 如果对于所有足够大的$n$，$T(N)$的上界和下界由$h(N)$的常数倍决定，也就是说，如果存在正常数$c_1,c_2$和$n_0$，使得当$N \ge n_0$时， 都有$c_1 g(N) \le T(N) \le c_2 g(N)$，则记为$ T(N) = \Th(g(N))$。
\item 如果$ T(N) = \bigo(p(N))$ 且$T(N) \neq \Th(p(N))$，则$T(N) = o(p(N))$。
\end{enumerate}
\end{definition}

\subsection{算法复杂度的性质}
\begin{theorem}
如果$T_{1}(N) = \bigo(f(N))$且$T_{2}(N) = \bigo(g(N))$， 那么
	\begin{itemize}
	\item $T_{1}(N) + T_{2}(N) = \max \prt{\bigo(f(N)) + \bigo(g(N)) }$ 。
	\item $T_{1}(N) T_{2}(N) =\bigo \prt{f(N)g(N)} $。
	\end{itemize}
\label{theorem_property_1}
\end{theorem}


\begin{proof}

\end{proof}


\begin{theorem}
\item 对于任意常数$k$， $\log^kN = \bigo(N)$。该条定理说明对数增长非常缓慢。
\end{theorem}


\subsection{复杂度方程的解法}
\begin{lemma}
假设定义在非负整数上的函数$f(n),g(n)$满足关系$f(n) = af(\frac{n}{b})+g(n)$， 其中实数$a\ge 1$，整数$b>1, n >0, k >0$且$n=b^k$，则有
\begin{eqnarray*}
f(n) = a^kf(1) + \sum_{j=1}^{k-1} a^j g(\frac{n}{b^j})
\end{eqnarray*} 
\label{lemma_f_n_solution}
\end{lemma}

\begin{proof}
由$f(n),g(n)$的关系联立得到$k$个等式
\begin{eqnarray*}
f(n) &=& af(\frac{n}{b})+g(n) \\
f(\frac{n}{b}) &=& af(\frac{n}{b^2})+g(\frac{n}{b}) \\
&...& \\
f(b) &=& af(1)+g(b) \\
\end{eqnarray*} 

对这$k$个等式依次两边分别乘以$1, a, a^1,...a^{k-1}$，再求和，消去相等的项，得到
\begin{eqnarray*}
f(n)  = a^kf(1) + \sum_{j=0}^{k-1} a^j g(\frac{n}{b^j})
\end{eqnarray*} 

\end{proof}


\begin{theorem}[Master Theorem]\mbox{}\par
$T(N)$是定义在非负整数的函数，满足
\begin{eqnarray*}
T(N) = aT(\frac{N}{b}) + cN^k
\end{eqnarray*} 
其中$a, k$为实数， $b$为整数，且$a\ge 1, b>1$, 另外满足$N=b^m, m$为整数, 则

\begin{eqnarray*}
T(N) = \begin{cases}
\bigo{(N^{\log_b a})} \quad a>b^k\\
\bigo{(N^k\log N)} \quad a=b^k \\
\bigo{(N^k)} \quad\quad a<b^k\\
\end{cases}
\end{eqnarray*} 

\begin{proof}

根据引理(\ref{lemma_f_n_solution})可知

\begin{eqnarray}
T(N) &=& a^mT(1) + c\sum_{j=0}^{m-1} a^j \left( \frac{N}{b^j}\right)^k \nonumber \\
&=& a^{\log_{b} N}T(1) +  cN^k\sum_{j=0}^{\log_{b} N-1}  \left( \frac{a}{b^{k}}\right)^j
\label{Master_theorem_T_base_formula}
\end{eqnarray}


当$a=b^k$, 公式(\ref{Master_theorem_T_base_formula})等价于
\begin{eqnarray*}
&&b^{k\log_{b} N}T(1) +  cN^k\sum_{j=0}^{\log_{b} N-1}  \left( \frac{b^{k}}{b^{k}}\right)^j \\
&=&\left(b^{\log_{b} N}\right)^kT(1) +cN^k\log_{b} N \\
&=& N^kT(1) + +cN^k\log_{b} N
\end{eqnarray*}

根据定理(\ref{theorem_property_1})算法的复杂度由具有较大增长次数的部分决定， 那么
\begin{eqnarray*}
T(N) = \bigo(N^k \log_{b} N ) = \bigo(N^k \log N)
\end{eqnarray*}

\end{proof}









\end{theorem}


