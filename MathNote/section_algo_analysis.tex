\section{算法分析}


\subsection{算法复杂度的数学定义}
\begin{definition}
关于算法的复杂度本文使用如下定义

\begin{enumerate}
\item 如果对于所有足够大的$n$，$T(N)$的上界由$f(N)$的常数倍决定，也就是说，如果存在正常数$c$和$n_0$，使得当$N \ge n_0$时， 都有$T(N) \le cf(N)$，则记为$ T(N) = \bigo(f(N))$。
\item 对于所有足够大的$n$，$T(N)$的下界由$g(N)$的常数倍决定， 也就是说，如果存在正常数$c$和$n_0$，使得当$N \ge n_0$时， 都有$T(N) \ge cg(N)$，则记为$ T(N) = \Om(g(N))$。
\item 如果对于所有足够大的$n$，$T(N)$的上界和下界由$h(N)$的常数倍决定，也就是说，如果存在正常数$c_1,c_2$和$n_0$，使得当$N \ge n_0$时， 都有$c_1 g(N) \le T(N) \le c_2 g(N)$，则记为$ T(N) = \Th(g(N))$。
\item 如果$ T(N) = \bigo(p(N))$ 且$T(N) \neq \Th(p(N))$，则$T(N) = o(p(N))$。
\end{enumerate}
\end{definition}

\subsection{算法复杂度的性质}
\begin{theorem}
如果$T_{1}(N) = \bigo(f(N))$且$T_{2}(N) = \bigo(g(N))$， 那么
	\begin{itemize}
	\item $T_{1}(N) + T_{2}(N) = \max \prt{\bigo(f(N)) + \bigo(g(N)) }$ 。
	\item $T_{1}(N) T_{2}(N) =\bigo \prt{f(N)g(N)} $。
	\end{itemize}
\end{theorem}


\begin{proof}

\end{proof}


\begin{theorem}
\item 对于任意常数$k$， $\log^kN = \bigo(N)$。该条定理说明对数增长非常缓慢。
\end{theorem}


\subsection{复杂度方程的解法}
\begin{lemma}
假设定义在非负整数上的函数$f(n),g(n)$满足关系$f(n) = af(\frac{n}{b})+g(n)$， 其中实数$a\ge 1$，整数$b>1, n >0, k >0$且$n=b^k$，则有
\begin{eqnarray*}
f(n) = a^kf(1) + \sum_{j=1}^{k-1} a^j g(\frac{n}{b^j})
\end{eqnarray*} 
\end{lemma}

\begin{proof}
由$f(n),g(n)$的关系联立得到$k$个等式
\begin{eqnarray*}
f(n) &=& af(\frac{n}{b})+g(n) \\
f(\frac{n}{b}) &=& af(\frac{n}{b^2})+g(\frac{n}{b}) \\
&...& \\
f(b) &=& af(1)+g(b) \\
\end{eqnarray*} 

对这$k$个等式依次两边分别乘以$1, a, a^1,...a^{k-1}$，再求和，消去相等的项，得到
\begin{eqnarray*}
f(n)  = a^kf(1) + \sum_{j=1}^{k-1} a^j g(\frac{n}{b^j})
\end{eqnarray*} 

\end{proof}


\begin{theorem}[Master Theorem]\mbox{}\par
$T(N)$是定义在非负整数的函数，满足
\begin{eqnarray*}
T(N) = aT(\frac{N}{b}) + cN^k
\end{eqnarray*} 
其中实数$a\ge 1$，整数$b>1, N >0, k >0$且$N=b^k$, 则

\begin{eqnarray*}
T(N) = \begin{cases}
\bigo{(N^{\log_b a})} \quad a>b^k\\
\bigo{(N^k\log N)} \quad a=b^k \\
\bigo{(N^k)} \quad\quad a<b^k\\
\end{cases}
\end{eqnarray*} 

\begin{proof}

\end{proof}









\end{theorem}


